name: 1. Deploy Smart Agent

on:
  workflow_dispatch:
    inputs:
      batch_size:
        description: 'Number of hosts per batch'
        required: false
        default: '256'
        type: string

jobs:
  prepare:
    runs-on: self-hosted
    outputs:
      batches: ${{ steps.create-batches.outputs.batches }}
      total_hosts: ${{ steps.create-batches.outputs.total_hosts }}
      total_batches: ${{ steps.create-batches.outputs.total_batches }}
    steps:
      - id: create-batches
        run: |
          # Parse hosts and remove empty lines
          HOSTS=$(echo "${{ vars.DEPLOYMENT_HOSTS }}" | tr -d '\r' | grep -v '^$')
          
          # Count total hosts
          TOTAL=$(echo "$HOSTS" | wc -l | xargs)
          echo "total_hosts=$TOTAL" >> $GITHUB_OUTPUT
          
          # Batch size from input or default
          BATCH_SIZE=${{ github.event.inputs.batch_size || '256' }}
          
          # Calculate number of batches needed
          TOTAL_BATCHES=$(( (TOTAL + BATCH_SIZE - 1) / BATCH_SIZE ))
          echo "total_batches=$TOTAL_BATCHES" >> $GITHUB_OUTPUT
          
          # Create batches as JSON array
          BATCHES=$(echo "$HOSTS" | awk -v batch_size=$BATCH_SIZE '
            BEGIN { batch=0; print "[" }
            {
              if (NR % batch_size == 1) {
                if (NR > 1) { print "]" }
                if (NR > 1) { print "," }
                print "["
                printf "\"%s\"", $0
              } else {
                printf ",\"%s\"", $0
              }
            }
            END { if (NR > 0) { print "]" }; print "]" }
          ' | jq -c .)
          
          echo "batches=$BATCHES" >> $GITHUB_OUTPUT
          
          echo "üìä Deploying to $TOTAL hosts across $TOTAL_BATCHES batches"

---

  deploy-batch:
    needs: prepare
    runs-on: self-hosted
    strategy:
      max-parallel: 1  # Run batches sequentially to avoid overwhelming resources
      matrix:
        batch: ${{ fromJson(needs.prepare.outputs.batches) }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Deploy to batch hosts
        run: |
          BATCH_HOSTS='${{ toJson(matrix.batch) }}'
          BATCH_SIZE=$(echo "$BATCH_HOSTS" | jq '. | length')
          SSH_USER="${{ vars.SSH_USER || 'ubuntu' }}"
          echo "üöÄ Deploying to batch of $BATCH_SIZE hosts"
          
          # Define the full remote deployment script in a shell variable
          # Note: We use 'EOF' here to ensure the script content is clean
          # and the $SMARTAGENT_USER/$SMARTAGENT_GROUP are passed as environment variables.
          REMOTE_SCRIPT=$(cat << 'EOF'
            set -e
            
            # The variables SMARTAGENT_USER and SMARTAGENT_GROUP are already set 
            # as environment variables by the parent shell before 'bash -s' starts.

            sudo apt-get update -qq && sudo apt-get install -y unzip
            sudo rm -rf /opt/appdynamics/appdsmartagent
            sudo mkdir -p /opt/appdynamics/appdsmartagent
            
            # Unzip and copy config file from /tmp (where scp placed them)
            sudo unzip /tmp/appdsmartagent_64_linux_25.10.0.497.zip -d /opt/appdynamics/appdsmartagent
            sudo cp /tmp/config.ini /opt/appdynamics/appdsmartagent/config.ini
            
            cd /opt/appdynamics/appdsmartagent
            
            # Start agent, checking if optional user/group vars were provided
            if [ -n "$SMARTAGENT_USER" ] && [ -n "$SMARTAGENT_GROUP" ]; then 
              echo "Starting agent with user/group: $SMARTAGENT_USER/$SMARTAGENT_GROUP"
              sudo ./smartagentctl start --enable-auto-attach --service --user "$SMARTAGENT_USER" --group "$SMARTAGENT_GROUP"
            else 
              echo "Starting agent with default user/group"
              sudo ./smartagentctl start --enable-auto-attach --service
            fi
            
            echo "Remote script completed successfully."
EOF
          )

          # Process each host in the batch in parallel using background processes
          echo "$BATCH_HOSTS" | jq -r '.[]' | while read HOST; do
            (
              echo "üì° Starting deployment to $HOST"
              
              # Setup SSH
              mkdir -p ~/.ssh
              echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa_$HOST
              chmod 600 ~/.ssh/id_rsa_$HOST
              
              # Copy files - error handling remains the same
              if ! scp -i ~/.ssh/id_rsa_$HOST \
                  -o StrictHostKeyChecking=no \
                  -o UserKnownHostsFile=/dev/null \
                  -o ConnectTimeout=30 \
                  appdsmartagent_64_linux_25.10.0.497.zip "${SSH_USER}@${HOST}:/tmp/" \
                  config.ini "${SSH_USER}@${HOST}:/tmp/"; then # Combined SCP for brevity
                echo "‚ùå Failed to copy files to $HOST" >&2
                rm -f ~/.ssh/id_rsa_$HOST
                echo "$HOST" >> /tmp/failed_hosts_$$
                exit 1
              fi
              
              # Deploy and start agent using the piped script
              SMARTAGENT_USER="${{ vars.SMARTAGENT_USER }}"
              SMARTAGENT_GROUP="${{ vars.SMARTAGENT_GROUP }}"
              
              # 1. Pipe the script to the SSH command
              # 2. Pass SMARTAGENT variables as environment variables
              # 3. Execute the script with 'bash -s'
              if echo "$REMOTE_SCRIPT" | ssh -i ~/.ssh/id_rsa_$HOST \
                  -o StrictHostKeyChecking=no \
                  -o UserKnownHostsFile=/dev/null \
                  -o ConnectTimeout=30 \
                  "${SSH_USER}@${HOST}" "SMARTAGENT_USER='$SMARTAGENT_USER' SMARTAGENT_GROUP='$SMARTAGENT_GROUP' bash -s"; then
                
                echo "‚úÖ Completed deployment to $HOST"
              else
                echo "‚ùå Failed to deploy to $HOST" >&2
                echo "$HOST" >> /tmp/failed_hosts_$$
              fi
              
              # Cleanup
              rm -f ~/.ssh/id_rsa_$HOST
            ) &
          done
          
          # Wait for all parallel deployments to complete
          wait
          
          if [ -f /tmp/failed_hosts_$$ ]; then
            echo "‚ùå Some hosts failed:"
            cat /tmp/failed_hosts_$$
            rm -f /tmp/failed_hosts_$$
            exit 1
          fi
          echo "‚úÖ Batch deployment complete"

---

  summary:
    needs: [prepare, deploy-batch]
    runs-on: self-hosted
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          echo "üìä Deployment Summary"
          echo "===================="
          echo "Total hosts: ${{ needs.prepare.outputs.total_hosts }}"
          echo "Total batches: ${{ needs.prepare.outputs.total_batches }}"
          echo "Status: ${{ needs.deploy-batch.result }}"
